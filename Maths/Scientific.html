<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scientific Calculator — Fixed</title>
<style>
  :root{
    --page-bg: #ffffff;
    --card-bg: linear-gradient(180deg,#07121a 0%, #06101a 100%);
    --key:#12202a;
    --key-hover:#162b34;
    --accent:#10b981;
    --accent-600:#05956f;
    --danger:#dc2626;
    --muted:#94a3b8;
    --shadow:0 14px 40px rgba(15,23,42,0.12);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:var(--page-bg);display:flex;align-items:center;justify-content:center;padding:28px}
  .calculator{
    width:360px; max-width:96vw;
    background:var(--card-bg);
    border-radius:18px;
    box-shadow:var(--shadow);
    color:#e6eef8;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.03);
    display:flex;flex-direction:column;
  }
  .top{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,0.03)}
  .brand{display:flex;flex-direction:column}
  .title{font-weight:700;font-size:16px}
  .subtitle{font-size:12px;color:var(--muted);margin-top:4px}
  .modeToggle{display:flex;gap:8px}
  .modeToggle button{border:0;padding:7px 12px;border-radius:999px;background:transparent;color:var(--muted);font-weight:700;cursor:pointer}
  .modeToggle button.active{background:var(--accent);color:#04201b;box-shadow:0 6px 20px rgba(6,139,107,0.12)}

  /* DISPLAY: white area with black text as requested */
  .displayWrap{padding:12px}
  .display{
    background:#ffffff;border-radius:10px;padding:12px;min-height:80px;display:flex;flex-direction:column;justify-content:center;
  }
  .expr{color:#334155;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .result{font-family:ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;font-size:32px;text-align:right;color:#041018;margin-top:6px;word-break:break-all}

  /* KEYS: 5-column grid for consistent layout */
  .keys{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;padding:14px}
  .key{background:var(--key);border-radius:12px;padding:12px;font-size:14px;border:0;color:#e6f0fb;cursor:pointer;display:flex;align-items:center;justify-content:center;min-height:44px;box-shadow:inset 0 -3px 0 rgba(0,0,0,0.25);transition:transform .08s,background .08s}
  .key:hover{transform:translateY(-3px);background:var(--key-hover)}
  .key:active{transform:translateY(0);background:var(--key-hover)}
  .key.ac{background:var(--danger);color:white}
  .key.equals{background:linear-gradient(180deg,var(--accent),var(--accent-600));color:#04201b;box-shadow:0 10px 30px rgba(6,139,107,0.18)}
  .key.wide{grid-column:span 2}
  .muted{color:var(--muted);font-size:12px}
  .status{padding:10px 14px;border-top:1px solid rgba(255,255,255,0.02);display:flex;justify-content:space-between;color:var(--muted);font-size:13px}

  @media (max-width:380px){
    .calculator{width:320px}
    .result{font-size:28px}
    .keys{gap:8px;padding:10px}
    .key{padding:10px;font-size:13px;min-height:40px}
  }
  .key:focus{outline:3px solid rgba(255,255,255,0.06);outline-offset:2px}
</style>
</head>
<body>
  <div class="calculator" role="application" aria-label="Scientific calculator">
    <div class="top">
      <div class="brand">
        <div class="title">Scientific Calculator</div>
        <div class="subtitle">Keyboard · Deg/Rad · Memory · Precise</div>
      </div>
      <div class="modeToggle" role="tablist" aria-label="Angle mode">
        <button id="degBtn" class="active" aria-pressed="true">Deg</button>
        <button id="radBtn" aria-pressed="false">Rad</button>
      </div>
    </div>

    <!-- DISPLAY: WHITE + BLACK text -->
    <div class="displayWrap">
      <div class="display" aria-live="polite">
        <div id="exprSmall" class="expr"></div>
        <div id="exprBig" class="result">0</div>
      </div>
    </div>

    <!-- KEYS: stable 5-column layout -->
    <div class="keys" id="keys" role="group" aria-label="Calculator buttons">
      <!-- row1 -->
      <button class="key" data-key="sin(">sin</button>
      <button class="key" data-key="cos(">cos</button>
      <button class="key" data-key="tan(">tan</button>
      <button class="key" data-key="asin(">sin⁻¹</button>
      <button class="key" data-key="acos(">cos⁻¹</button>

      <!-- row2 -->
      <button class="key" data-key="atan(">tan⁻¹</button>
      <button class="key" data-key="^">xʸ</button>
      <button class="key" data-key="^2">x²</button>
      <button class="key" data-key="^3">x³</button>
      <button class="key" data-key="sqrt(">√x</button>

      <!-- row3 -->
      <button class="key" data-key="cbrt(">³√x</button>
      <button class="key" data-key="root(">y√x</button>
      <button class="key" data-key="ln(">ln</button>
      <button class="key" data-key="log(">log</button>
      <button class="key" data-key="expE(">eˣ</button>

      <!-- row4 -->
      <button class="key" data-key="exp10(">10ˣ</button>
      <button class="key" data-key="PI">π</button>
      <button class="key" data-key="E">e</button>
      <button class="key" data-key="("> ( </button>
      <button class="key" data-key=")"> ) </button>

      <!-- row5 -->
      <button class="key" data-key="1/x">1/x</button>
      <button class="key" data-key="%">%</button>
      <button class="key" data-key="!">n!</button>
      <button class="key" data-key="rand">RND</button>
      <button class="key" data-key="CE">CE</button>

      <!-- row6 -->
      <button class="key ac" data-key="AC">AC</button>
      <button class="key" data-key="back">⌫</button>
      <button class="key" data-key="neg">±</button>
      <button class="key" data-key="MC">MC</button>
      <button class="key" data-key="MR">MR</button>

      <!-- row7 -->
      <button class="key" data-key="7">7</button>
      <button class="key" data-key="8">8</button>
      <button class="key" data-key="9">9</button>
      <button class="key" data-key="/">÷</button>
      <button class="key" data-key="M+">M+</button>

      <!-- row8 -->
      <button class="key" data-key="M-">M-</button>
      <button class="key" data-key="4">4</button>
      <button class="key" data-key="5">5</button>
      <button class="key" data-key="6">6</button>
      <button class="key" data-key="*">×</button>

      <!-- row9 -->
      <button class="key" data-key="Ans">Ans</button>
      <button class="key" data-key="EXP">EXP</button>
      <button class="key" data-key="1">1</button>
      <button class="key" data-key="2">2</button>
      <button class="key" data-key="3">3</button>

      <!-- row10 -->
      <button class="key" data-key="-">-</button>
      <button class="key wide" data-key="0">0</button>
      <button class="key" data-key=".">.</button>
      <button class="key" data-key="+">+</button>
      <button class="key equals" data-key="=">=</button>
    </div>

    <div class="status">
      <div>Memory: <span id="memVal">0</span></div>
      <div>Ans: <span id="ansVal">0</span></div>
    </div>
  </div>

<script>
/* Robust expression engine: tokenize -> shunting-yard -> RPN evaluate
   Fixes: function token handling and postfix operators; reliable results for trig and top-row functions.
*/
(function(){
  // UI refs
  const exprSmall = document.getElementById('exprSmall');
  const exprBig = document.getElementById('exprBig');
  const keys = document.getElementById('keys');
  const degBtn = document.getElementById('degBtn');
  const radBtn = document.getElementById('radBtn');
  const memVal = document.getElementById('memVal');
  const ansVal = document.getElementById('ansVal');

  // state
  let expression = '';
  let memory = 0;
  let ANS = 0;
  let degMode = true;

  // normalize numbers to avoid floating noise
  function normalizeNumber(x){
    if(typeof x !== 'number' || !isFinite(x)) return x;
    return Number.parseFloat(x.toPrecision(12));
  }

  // TOKENIZER
  function tokenize(input){
    const s = String(input);
    const tokens = [];
    let i = 0;
    const reNumber = /^[0-9]+(?:\.[0-9]*)?(?:[eE][+\-]?\d+)?/;
    const reIdent = /^[A-Za-z_][A-Za-z0-9_]*/;
    while(i < s.length){
      const ch = s[i];
      if(/\s/.test(ch)){ i++; continue; }
      // number
      const mNum = s.slice(i).match(reNumber);
      if(mNum){ tokens.push({type:'number', value:mNum[0]}); i += mNum[0].length; continue; }
      // identifier (functions/constants)
      const mId = s.slice(i).match(reIdent);
      if(mId){ tokens.push({type:'ident', value:mId[0]}); i += mId[0].length; continue; }
      // single char operator/paren/comma
      if(ch === '+'||ch === '-'||ch === '*'||ch === '/'||ch === '^'||ch === '('||ch === ')'||ch === ','){
        tokens.push({type:'op', value:ch}); i++; continue;
      }
      if(ch === '!'){ tokens.push({type:'postfix', value:'!'}); i++; continue; }
      if(ch === '%'){ tokens.push({type:'postfix', value:'%'}); i++; continue; }
      if(ch === 'π' || ch === 'Π'){ tokens.push({type:'ident', value:'PI'}); i++; continue; }
      // fallback: treat single char as unknown token
      tokens.push({type:'unknown', value:ch});
      i++;
    }
    return tokens;
  }

  // SHUNTING-YARD -> RPN
  function toRPN(tokens){
    const out = [];
    const ops = [];
    const prec = { '+':2, '-':2, '*':3, '/':3, '^':4 };
    const rightAssoc = { '^': true };

    for(let i=0;i<tokens.length;i++){
      const t = tokens[i];
      if(t.type === 'number' || (t.type === 'ident' && !isFunctionLike(t,i,tokens))){
        out.push(t);
      } else if(t.type === 'ident' && isFunctionLike(t,i,tokens)){
        // function: push as func token
        ops.push({type:'func', value:t.value});
      } else if(t.type === 'op'){
        if(t.value === '('){
          ops.push(t);
        } else if(t.value === ')'){
          while(ops.length && !(ops[ops.length-1].type === 'op' && ops[ops.length-1].value === '(')){
            out.push(ops.pop());
          }
          if(ops.length && ops[ops.length-1].type === 'op' && ops[ops.length-1].value === '(') ops.pop();
          if(ops.length && ops[ops.length-1].type === 'func') out.push(ops.pop());
        } else {
          // unary minus detection (if '-' and prev is start or operator or '(')
          const prev = tokens[i-1];
          if(t.value === '-' && (!prev || (prev.type === 'op' && prev.value !== ')') || prev.type === 'postfix')){
            ops.push({type:'op', value:'u-'});
            continue;
          }
          while(ops.length){
            const top = ops[ops.length-1];
            if(top.type === 'op' && top.value !== '('){
              const tp = prec[top.value] || 0;
              const cp = prec[t.value] || 0;
              if((!rightAssoc[t.value] && cp <= tp) || (rightAssoc[t.value] && cp < tp)){
                out.push(ops.pop());
                continue;
              }
            } else if(top.type === 'func'){
              out.push(ops.pop());
              continue;
            }
            break;
          }
          ops.push(t);
        }
      } else if(t.type === 'postfix'){
        // push postfix directly to output (so they apply to last value)
        out.push(t);
      } else {
        // unknown -> push raw
        out.push(t);
      }
    }
    while(ops.length) out.push(ops.pop());
    return out;
  }

  function isFunctionLike(token, index, tokens){
    // function if ident and next non-space token is '('
    const next = tokens[index+1];
    return !!(next && next.type === 'op' && next.value === '(');
  }

  // RPN EVALUATOR
  function evaluateRPN(rpn){
    const st = [];
    const consts = { PI: Math.PI, E: Math.E, Ans: ANS };
    const funcs = {
      sin: (x)=> degMode ? Math.sin(x*Math.PI/180) : Math.sin(x),
      cos: (x)=> degMode ? Math.cos(x*Math.PI/180) : Math.cos(x),
      tan: (x)=> degMode ? Math.tan(x*Math.PI/180) : Math.tan(x),
      asin: (x)=> degMode ? Math.asin(x)*180/Math.PI : Math.asin(x),
      acos: (x)=> degMode ? Math.acos(x)*180/Math.PI : Math.acos(x),
      atan: (x)=> degMode ? Math.atan(x)*180/Math.PI : Math.atan(x),
      ln: (x)=> Math.log(x),
      log: (x)=> (Math.log10 ? Math.log10(x) : Math.log(x)/Math.LN10),
      expE: (x)=> Math.exp(x),
      exp10: (x)=> Math.pow(10,x),
      sqrt: (x)=> Math.sqrt(x),
      cbrt: (x)=> Math.cbrt ? Math.cbrt(x) : Math.pow(x,1/3),
      root: (y,x)=> Math.pow(x, 1/y),
      rand: ()=> Math.random()
    };

    for(let i=0;i<rpn.length;i++){
      const t = rpn[i];
      if(t.type === 'number'){ st.push(Number(t.value)); }
      else if(t.type === 'ident'){
        const name = t.value;
        if(name in consts) st.push(consts[name]);
        else st.push(NaN);
      } else if(t.type === 'postfix'){
        if(t.value === '!'){
          const a = st.pop();
          const n = Number(a);
          if(!Number.isInteger(n) || n < 0) throw new Error('factorial');
          if(n > 170) throw new Error('factorial overflow');
          let f=1; for(let k=1;k<=n;k++) f *= k;
          st.push(f);
        } else if(t.value === '%'){
          const a = st.pop();
          st.push(Number(a)/100);
        } else throw new Error('postfix');
      } else if(t.type === 'op'){
        if(t.value === 'u-'){ const a = st.pop(); st.push(-Number(a)); }
        else {
          const b = st.pop(); const a = st.pop();
          if(t.value === '+') st.push(Number(a)+Number(b));
          else if(t.value === '-') st.push(Number(a)-Number(b));
          else if(t.value === '*') st.push(Number(a)*Number(b));
          else if(t.value === '/'){ if(Number(b)===0) throw new Error('div0'); st.push(Number(a)/Number(b)); }
          else if(t.value === '^') st.push(Math.pow(Number(a), Number(b)));
          else throw new Error('op');
        }
      } else if(t.type === 'func'){
        const name = t.value;
        if(name === 'root'){
          const x = st.pop(); const y = st.pop(); st.push(funcs.root(Number(y),Number(x)));
        } else if(name === 'rand'){ st.push(funcs.rand()); }
        else {
          const a = st.pop();
          if(!(name in funcs)) throw new Error('func');
          st.push(funcs[name](Number(a)));
        }
      } else {
        // unknown token — push NaN
        st.push(NaN);
      }
    }

    if(st.length !== 1) throw new Error('syntax');
    return st[0];
  }

  // Full evaluate wrapper
  function prepareAndEvaluate(raw){
    if(!raw || raw.trim()==='') return 0;
    // small sanitizations
    let s = String(raw).replace(/×/g,'*').replace(/÷/g,'/');
    // handle implicit multiplication like 2PI or )(
    s = s.replace(/(\d)(PI|Ans|E|\()/g,'$1*$2').replace(/(\))(\d|PI|Ans|E|\()/g,')*$2');
    // Tokenize
    const tokens = tokenize(s);
    const rpn = toRPN(tokens);
    return normalizeNumber(evaluateRPN(rpn));
  }

  // UI updates
  function updateUI(){
    exprSmall.textContent = expression;
    exprBig.textContent = expression === '' ? '0' : expression;
    memVal.textContent = String(memory);
    ansVal.textContent = String(ANS);
  }

  // Button handling
  keys.addEventListener('click', (ev)=>{
    const b = ev.target.closest('button');
    if(!b) return;
    const k = b.dataset.key;
    handleKey(k);
    b.blur();
  });

  // Keyboard support
  window.addEventListener('keydown', (ev)=>{
    if(ev.key === 'Enter'){ handleKey('='); ev.preventDefault(); return; }
    if(ev.key === 'Escape'){ handleKey('AC'); ev.preventDefault(); return; }
    if(ev.key === 'Backspace'){ handleKey('back'); ev.preventDefault(); return; }
    if(/[0-9]/.test(ev.key)) { handleKey(ev.key); return; }
    if(ev.key === '.') { handleKey('.'); return; }
    if(ev.key === '+') { handleKey('+'); return; }
    if(ev.key === '-') { handleKey('-'); return; }
    if(ev.key === '*') { handleKey('*'); return; }
    if(ev.key === '/') { handleKey('/'); return; }
    if(ev.key === '^') { handleKey('^'); return; }
  });

  function handleKey(k){
    if(k === undefined) return;
    try{
      switch(k){
        case 'AC': expression=''; updateUI(); break;
        case 'CE':
          expression = expression.replace(/\s*([A-Za-z_][A-Za-z0-9_]*|\d+\.?\d*(?:[eE][+\-]?\d+)?|\S)$/, '');
          updateUI();
          break;
        case 'back': expression = expression.slice(0,-1); updateUI(); break;
        case '=':
          try{
            const val = prepareAndEvaluate(expression);
            if(val === 'Error' || Number.isNaN(val)){ exprBig.textContent='Error'; }
            else {
              const display = normalizeNumber(val);
              ANS = (typeof display === 'number') ? display : Number(display)||0;
              expression = String(display);
              exprSmall.textContent = '';
              exprBig.textContent = expression;
              ansVal.textContent = String(ANS);
            }
          } catch(e){
            exprBig.textContent = 'Error';
          }
          break;
        case 'neg':
          expression = expression.replace(/(\d+\.?\d*(?:[eE][+\-]?\d+)?)$/,(m)=> String(-Number(m)));
          updateUI();
          break;
        case '1/x':
          {
            const v = prepareAndEvaluate(expression);
            if(v === 'Error' || Number(v) === 0) { exprBig.textContent='Error'; }
            else { const r = normalizeNumber(1/Number(v)); ANS = r; expression = String(r); updateUI(); exprBig.textContent=expression; }
          }
          break;
        case '%': expression += '%'; updateUI(); break;
        case '!': expression += '!'; updateUI(); break;
        case 'rand': expression = String(Math.random()); updateUI(); break;
        case 'MC': memory = 0; memVal.textContent = String(memory); break;
        case 'MR': expression += String(memory); updateUI(); break;
        case 'M+': { const v = prepareAndEvaluate(expression); if(!(v==='Error')) memory += Number(v); memVal.textContent=String(memory); } break;
        case 'M-': { const v = prepareAndEvaluate(expression); if(!(v==='Error')) memory -= Number(v); memVal.textContent=String(memory); } break;
        case 'Ans': expression += 'Ans'; updateUI(); break;
        case 'EXP': expression += 'e'; updateUI(); break;
        case 'E_not': expression += 'E'; updateUI(); break;
        default:
          // append token as-is (functions include '(' on buttons)
          expression += k;
          updateUI();
      }
    } catch(e){
      // any unexpected runtime error -> show Error, don't crash
      exprBig.textContent = 'Error';
    }
  }

  // deg/rad toggle
  degBtn.addEventListener('click', ()=>{ degMode = true; degBtn.classList.add('active'); degBtn.setAttribute('aria-pressed','true'); radBtn.classList.remove('active'); radBtn.setAttribute('aria-pressed','false'); });
  radBtn.addEventListener('click', ()=>{ degMode = false; radBtn.classList.add('active'); radBtn.setAttribute('aria-pressed','true'); degBtn.classList.remove('active'); degBtn.setAttribute('aria-pressed','false'); });

  // initial display
  updateUI();

  // expose evaluate for debugging if needed
  window.__calc = { evaluate: (s)=> { try { return prepareAndEvaluate(String(s)); } catch(e) { return 'Error' } } };

})();
</script>
</body>
</html>
