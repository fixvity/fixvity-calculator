import React, { useState } from 'react';

// ScientificCalculator.jsx
// Single-file React component (Tailwind CSS) that implements a scientific calculator
// Default export a React component. Copy into a React app that has Tailwind configured.

export default function ScientificCalculator() {
  const [expr, setExpr] = useState(''); // expression shown in input area
  const [display, setDisplay] = useState('0'); // main display (result or current number)
  const [degMode, setDegMode] = useState(true); // true -> Deg, false -> Rad
  const [memory, setMemory] = useState(0);
  const [ans, setAns] = useState(0);

  // helper math functions available to evaluator
  const helpers = {
    sin: (x) => (degMode ? Math.sin((x * Math.PI) / 180) : Math.sin(x)),
    cos: (x) => (degMode ? Math.cos((x * Math.PI) / 180) : Math.cos(x)),
    tan: (x) => (degMode ? Math.tan((x * Math.PI) / 180) : Math.tan(x)),
    asin: (x) => (degMode ? (Math.asin(x) * 180) / Math.PI : Math.asin(x)),
    acos: (x) => (degMode ? (Math.acos(x) * 180) / Math.PI : Math.acos(x)),
    atan: (x) => (degMode ? (Math.atan(x) * 180) / Math.PI : Math.atan(x)),
    ln: (x) => Math.log(x),
    log: (x) => Math.log10(x),
    exp10: (x) => Math.pow(10, x),
    expE: (x) => Math.exp(x),
    sqrt: (x) => Math.sqrt(x),
    cbrt: (x) => Math.cbrt ? Math.cbrt(x) : Math.pow(x, 1/3),
    pow: (a, b) => Math.pow(a, b),
    pi: Math.PI,
    e: Math.E,
    abs: Math.abs,
  };

  // safe evaluate expression using Function with helpers in scope
  function safeEvaluate(raw) {
    if (!raw || raw.trim() === '') return 0;
    try {
      // replace human-friendly tokens
      let s = raw
        .replace(/×/g, '*')
        .replace(/÷/g, '/')
        .replace(/\^/g, '**')
        .replace(/π/g, 'pi')
        .replace(/\bAns\b/g, `(${ans})`)
        .replace(/EXP\(/g, '(*10**') // handled separately when using EXP button
        ;

      // protect letters used by helpers: e.g. sin( -> helpers.sin(
      // We'll create a function body that has helpers in scope and use identifiers directly (sin, cos...)
      const fn = new Function(...Object.keys(helpers), `return (${s});`);
      const res = fn(...Object.values(helpers));
      if (Number.isFinite(res)) return res;
      return String(res);
    } catch (e) {
      return 'Error';
    }
  }

  function appendToExpr(token) {
    // Prevent double leading zeros
    const newExpr = expr + token;
    setExpr(newExpr);
    setDisplay(newExpr);
  }

  function handleClear() {
    setExpr('');
    setDisplay('0');
  }

  function handleCE() {
    // Clear last entry: remove last number or operator
    if (!expr) { handleClear(); return; }
    // naive: remove last token (either digit sequence, or non-digit)
    const trimmed = expr.replace(/\s+$/,'');
    // remove last chunk of digits, or last non-digit
    const newExpr = trimmed.replace(/\d+\.?\d*$|[()+\-*/%^]$/,'');
    setExpr(newExpr);
    setDisplay(newExpr || '0');
  }

  function handleBackspace() {
    if (!expr) return handleClear();
    const e = expr.slice(0, -1);
    setExpr(e);
    setDisplay(e || '0');
  }

  function handleEquals() {
    const result = safeEvaluate(expr);
    setDisplay(String(result));
    setAns(Number(result) || 0);
    setExpr(String(result));
  }

  function handleImmediateOp(op) {
    // parse current displayed value
    let val = 0;
    if (expr) {
      const maybe = safeEvaluate(expr);
      if (maybe === 'Error') {
        setDisplay('Error');
        return;
      }
      val = Number(maybe);
    } else {
      val = Number(display) || 0;
    }

    let res;
    switch (op) {
      case '1/x':
        res = val === 0 ? 'Error' : 1 / val;
        break;
      case '%':
        // treat % as divide by 100 for current value
        res = val / 100;
        break;
      case 'n!':
        if (val < 0 || !Number.isInteger(val)) { res = 'Error'; break; }
        res = 1;
        for (let i = 1; i <= val; i++) res *= i;
        break;
      case '√':
        res = Math.sqrt(val);
        break;
      case '³√':
        res = helpers.cbrt(val);
        break;
      case '±':
        res = -val;
        break;
      case 'Ans':
        res = ans;
        break;
      case 'EXP':
        // treat as x * 10^y: user will press EXP then digits. We'll append 'e' notation
        // Instead of complex handling, append 'e' to expression
        appendToExpr('e');
        return;
      default:
        return;
    }
    setExpr(String(res));
    setDisplay(String(res));
    setAns(Number(res) || 0);
  }

  function handleFunction(fnName) {
    // append function name then (
    appendToExpr(fnName + '(');
  }

  function handleDigit(d) {
    // if last thing was a ) or factorial, need operator before digit
    appendToExpr(String(d));
  }

  function handleDot() {
    appendToExpr('.');
  }

  function handleOperator(op) {
    // map for display
    const map = { '+': '+', '-': '-', '×': '×', '÷': '÷', '×²': '^2' };
    appendToExpr(op);
  }

  function handlePi() {
    appendToExpr('π');
  }

  function handleE() {
    appendToExpr('e');
  }

  // Memory operations
  function memoryClear() {
    setMemory(0);
  }
  function memoryRecall() {
    appendToExpr(String(memory));
  }
  function memoryPlus() {
    const v = Number(safeEvaluate(expr) || display) || 0;
    setMemory((m) => m + v);
  }
  function memoryMinus() {
    const v = Number(safeEvaluate(expr) || display) || 0;
    setMemory((m) => m - v);
  }

  // UI layout button click handler
  function onButtonClick(key) {
    // common keys mapped
    if (key === 'AC') return handleClear();
    if (key === 'CE') return handleCE();
    if (key === '⌫') return handleBackspace();
    if (key === '=') return handleEquals();
    if (key === '.') return handleDot();
    if (['+', '-', '×', '÷', '^'].includes(key)) return handleOperator(key);
    if (key.match(/^\d$/)) return handleDigit(key);

    // functions
    if (key === 'sin' || key === 'cos' || key === 'tan' || key === 'sin⁻¹' || key === 'cos⁻¹' || key === 'tan⁻¹') {
      const map = {
        'sin': 'sin(',
        'cos': 'cos(',
        'tan': 'tan(',
        'sin⁻¹': 'asin(',
        'cos⁻¹': 'acos(',
        'tan⁻¹': 'atan(',
      };
      appendToExpr(map[key]);
      return;
    }

    if (key === 'ln') return appendToExpr('ln(');
    if (key === 'log') return appendToExpr('log(');
    if (key === 'eˣ') return appendToExpr('expE(');
    if (key === '10ˣ') return appendToExpr('exp10(');

    if (key === 'xʸ') return appendToExpr('**');
    if (key === 'x²') return appendToExpr('**2');
    if (key === 'x³') return appendToExpr('**3');
    if (key === '√x') return appendToExpr('sqrt(');
    if (key === '³√x') return appendToExpr('cbrt(');

    if (key === 'π') return handlePi();
    if (key === 'e') return handleE();

    if (key === '1/x' || key === '%' || key === 'n!' || key === '√' || key === '³√' || key === '±' || key === 'Ans' || key === 'EXP') return handleImmediateOp(key);

    // memory
    if (key === 'MC') return memoryClear();
    if (key === 'MR') return memoryRecall();
    if (key === 'M+') return memoryPlus();
    if (key === 'M-') return memoryMinus();

    // parentheses
    if (key === '(' || key === ')') return appendToExpr(key);

    // default fallback: append textual token
    appendToExpr(key);
  }

  return (
    <div className="max-w-sm mx-auto p-3">
      <div className="bg-slate-900 text-white rounded-2xl overflow-hidden shadow-lg">
        <div className="p-4 border-b border-slate-800 flex items-center justify-between">
          <div>
            <div className="text-sm font-semibold">Scientific Calculator</div>
            <div className="text-xs text-slate-400">Keyboard friendly · Deg/Rad · Memory</div>
          </div>
          <div className="flex items-center gap-2">
            <button
              onClick={() => setDegMode(true)}
              className={`px-3 py-1 rounded-full ${degMode ? 'bg-emerald-500 text-white' : 'bg-slate-800 text-slate-300'}`}>
              Deg
            </button>
            <button
              onClick={() => setDegMode(false)}
              className={`px-3 py-1 rounded-full ${!degMode ? 'bg-emerald-500 text-white' : 'bg-slate-800 text-slate-300'}`}>
              Rad
            </button>
          </div>
        </div>

        <div className="p-4">
          <div className="bg-gradient-to-b from-slate-800 to-slate-900 rounded-lg p-3 min-h-[60px]">
            <div className="text-slate-400 text-sm truncate">{expr || ''}</div>
            <div className="text-right text-3xl font-mono mt-1">{display}</div>
          </div>
        </div>

        <div className="p-4 grid grid-cols-6 gap-3">
          {[
            'sin','cos','tan','sin⁻¹','cos⁻¹','tan⁻¹',
            'xʸ','x²','x³','√x','³√x','y√x',
            'ln','log','eˣ','10ˣ','π','e',
            '(' ,')','1/x','%','n!','RND',
            'CE','AC','⌫','±','MC','MR',
            '7','8','9','÷','M+','M-',
            '4','5','6','×','Ans','EXP',
            '1','2','3','-','EXP','',
            '0','.','+','=','','',
          ].map((k, i) => {
            // some placeholders to maintain grid
            if (k === '') return <div key={i} />;
            const isAccent = k === 'AC';
            const isEquals = k === '=';
            return (
              <button
                key={i}
                onClick={() => onButtonClick(k)}
                className={`py-3 rounded-lg text-sm ${isAccent ? 'bg-red-600 text-white' : isEquals ? 'bg-emerald-400 text-slate-900' : 'bg-slate-800 text-slate-200'}`}>
                {k}
              </button>
            );
          })}
        </div>

      </div>
    </div>
  );
}
      
